// This is a skeleton starter React component generated by Plasmic.
// This file is owned by you, feel free to edit as you see fit.
import * as React from "react";
import {
  PlasmicPropertiesLayoutSection,
  DefaultPropertiesLayoutSectionProps
} from "./plasmic/flutter_builder/PlasmicPropertiesLayoutSection";
import { HTMLElementRefOf } from "@plasmicapp/react-web";

// Your component props start with props for variants and slots you defined
// in Plasmic, but you can add more here, like event handlers that you can
// attach to named nodes in your component.
//
// If you don't want to expose certain variants or slots as a prop, you can use
// Omit to hide them:
//
// interface PropertiesLayoutSectionProps extends Omit<DefaultPropertiesLayoutSectionProps, "hideProps1"|"hideProp2"> {
//   // etc.
// }
//
// You can also stop extending from DefaultPropertiesLayoutSectionProps altogether and have
// total control over the props for your component.
export interface PropertiesLayoutSectionProps
  extends DefaultPropertiesLayoutSectionProps {
  node?: any;
  onUpdate?: (newProps: any) => void;
}

function PropertiesLayoutSection_(
  props: PropertiesLayoutSectionProps,
  ref: HTMLElementRefOf<"div">
) {
  const { node, onUpdate, ...rest } = props;
  
  // Extraire les propriétés de layout du nœud
  const layout = node?.props?.layout || {
    expansion: "none",
    flex: 1,
    padding: { l: 0, t: 0, r: 0, b: 0 },
    alignment: { slot: "center", x: 0, y: 0 },
  };

  // Propriétés spécifiques selon le type de widget
  const rowProps = node?.props?.rowProps;
  const columnProps = node?.props?.columnProps;

  const handleFlexChange = (value: number) => {
    if (onUpdate) {
      onUpdate({
        layout: { ...layout, flex: value }
      });
    }
  };

  const handlePaddingChange = (side: 'l' | 't' | 'r' | 'b', value: number) => {
    if (onUpdate) {
      onUpdate({
        layout: { 
          ...layout, 
          padding: { ...layout.padding, [side]: value } 
        }
      });
    }
  };

  const handleAlignmentChange = (slot: string, x: number, y: number) => {
    if (onUpdate) {
      onUpdate({
        layout: { 
          ...layout, 
          alignment: { slot, x, y } 
        }
      });
    }
  };

  const handleRowPropsChange = (newRowProps: any) => {
    if (onUpdate && rowProps) {
      onUpdate({ rowProps: { ...rowProps, ...newRowProps } });
    }
  };

  const handleColumnPropsChange = (newColumnProps: any) => {
    if (onUpdate && columnProps) {
      onUpdate({ columnProps: { ...columnProps, ...newColumnProps } });
    }
  };

  const handleExpansionChange = (expansion: string) => {
    if (onUpdate) {
      onUpdate({
        layout: { ...layout, expansion }
      });
    }
  };

  return (
    <PlasmicPropertiesLayoutSection 
      frame148={{ ref }} 
      {...rest}
      overrides={{
        // Connecter les contrôles de largeur et hauteur
        widthTextfield: {
          value: layout.width?.toString() || "0",
          onValueChangeAction: (value: string) => {
            const numValue = parseFloat(value) || 0;
            if (onUpdate) {
              onUpdate({
                layout: { ...layout, width: numValue }
              });
            }
          }
        },
        heightTextfield: {
          value: layout.height?.toString() || "0",
          onValueChangeAction: (value: string) => {
            const numValue = parseFloat(value) || 0;
            if (onUpdate) {
              onUpdate({
                layout: { ...layout, height: numValue }
              });
            }
          }
        },
        // Connecter les contrôles de padding
        paddingLeftAndRightTextfield: {
          value: layout.padding?.l?.toString() || "0",
          onValueChangeAction: (value: string) => {
            const numValue = parseFloat(value) || 0;
            if (onUpdate) {
              onUpdate({
                layout: { 
                  ...layout, 
                  padding: { ...layout.padding, l: numValue, r: numValue } 
                }
              });
            }
          }
        },
        paddingTopAndBottomTextfield: {
          value: layout.padding?.t?.toString() || "0",
          onValueChangeAction: (value: string) => {
            const numValue = parseFloat(value) || 0;
            if (onUpdate) {
              onUpdate({
                layout: { 
                  ...layout, 
                  padding: { ...layout.padding, t: numValue, b: numValue } 
                }
              });
            }
          }
        },
        // Connecter le contrôle de flex
        flexTextfield: {
          value: layout.flex?.toString() || "1",
          onValueChangeAction: (value: string) => {
            const numValue = parseFloat(value) || 1;
            if (onUpdate) {
              onUpdate({
                layout: { ...layout, flex: numValue }
              });
            }
          }
        },
        // Connecter les contrôles d'alignement
        xAxisTextfield: {
          value: layout.alignment?.x?.toString() || "0",
          onValueChangeAction: (value: string) => {
            const numValue = parseFloat(value) || 0;
            if (onUpdate) {
              onUpdate({
                layout: { 
                  ...layout, 
                  alignment: { ...layout.alignment, x: numValue } 
                }
              });
            }
          }
        },
        yAxisTextfield: {
          value: layout.alignment?.y?.toString() || "0",
          onValueChangeAction: (value: string) => {
            const numValue = parseFloat(value) || 0;
            if (onUpdate) {
              onUpdate({
                layout: { 
                  ...layout, 
                  alignment: { ...layout.alignment, y: numValue } 
                }
              });
            }
          }
        },
        // Connecter le contrôle de gap pour les Row/Column
        gapTextfield: {
          value: rowProps?.itemsSpacing?.toString() || columnProps?.itemsSpacing?.toString() || "0",
          onValueChangeAction: (value: string) => {
            const numValue = parseFloat(value) || 0;
            if (onUpdate) {
              if (rowProps) {
                onUpdate({ rowProps: { ...rowProps, itemsSpacing: numValue } });
              } else if (columnProps) {
                onUpdate({ columnProps: { ...columnProps, itemsSpacing: numValue } });
              }
            }
          }
        },
        // Connecter les contrôles d'expansion
        defaultIcon: {
          selected: layout.expansion === "none",
          selectable: true,
          onClick: () => handleExpansionChange("none"),
          style: {
            opacity: layout.expansion === "none" ? 1 : 0.5
          }
        },
        flexibleIcon: {
          selected: layout.expansion === "flexible",
          selectable: true,
          onClick: () => handleExpansionChange("flexible"),
          style: {
            opacity: layout.expansion === "flexible" ? 1 : 0.5
          }
        },
        expandedIcon: {
          selected: layout.expansion === "expanded",
          selectable: true,
          onClick: () => handleExpansionChange("expanded"),
          style: {
            opacity: layout.expansion === "expanded" ? 1 : 0.5
          }
        }
      }}
    />
  );
}

const PropertiesLayoutSection = React.forwardRef(PropertiesLayoutSection_);
export default PropertiesLayoutSection;
